1) Line 12 prints 3. This is because i is incrementing until it is equal to the length of prices. Since prices has a length of 3, i is equal to 3 after the for loop finsihes executing. 
2) Line 13 prints 150. discountedPrice gets redeclared each time the loop executes, so line 13 prints out the value of discountedPrice from the final execution of the loop. In the final execution, prices[i] is equal to 300 and discount is equal to 0.5, so 300 * (1 - 0.5) is equal to 150.
3) Line 14 prints 150. In the previous question, I talked about how discountedPrice changes each time the loop iterates. finalPrice also changes value each time the loop iterates. We know that discountedPrice is 150 from the previous question, so Math.round(150 * 100) gives us 15000, and then 15000 / 100 is equal to 150. This means that finalPrice is equal to 150 when the loop finishes.
4) This function returns the array [50, 100, 150]. In the previous two questions, I explained how the values of discountedPrice and finalPrice are calculated during each iteration of the loop. At the end of each iteration, the value of finalPrice gets pushed into the discounted array. Then when the loop is finished executing, the discounted array gets returned. 
5) Line 12 causes a Reference Error which says that i isn't defined. This is because i was defined with the let keyword inside the for loop. Since line 12 isn't within that for loop, it cannot access i.
6) Line 13 also causes a Reference Error that says discountedPrice isn't defined. discountedPrice is defined inside the for loop so it can't be accessed by a line outside of that loop. 
7) Line 14 prints 150. finalPrice is declared using the let keyword just like i and discountedPrice, but it wasn't declared inside the for loop. This means that it can be accessed by another line that is within discountPrices function.
8) This function returns the array [50, 100, 150]. It returns this for the same reason as question 4. While the discounted array was declared using the let keyword, it wasn't declared within the for loop so it could be returned from within the function.
9) Line 11 causes a Reference Error that says i isn't defined. i is defined inside the for loop using the let keyword, so it can't be accessed outside of the loop. 
10) Line 12 prints 3. length is equal to the length of the array that is passed in when the function is called. length was declared using the const keyword, which means that its value can't be reassigned after it's declared. Since the code doesn't try to reassign the value of length, this didn't cause an error.
11) This function returns the array [50, 100, 150]. For each iteration of the for loop, discountedPrice gets redeclared with a new value. Even though it's declared with the const keyword, since it's getting redeclared each time, it doesn't cause an error. At the end of each loop, discountedPrice is pushed on to the discounted array. The discounted array is then returned at the end of the function. discounted is also declared with const but we can still push to it because pushing to a const array doesn't mean that we're reassigning it. 
12) A. student['name']  
    B. student['Grad Year']  
    C. student.greeting()  
    D. student['Favorite Teacher']['name']  
    E. student['courseload'][0]  
13) A. '32' | Integers map to their string representation so adding a string and an integer results in a string.  
    B. 1 | The subtraction operation can only mean subtraction, so the '3' has to be converted into an integer to complete the subtraction operation. This returns an integer.  
    C. 3 | When null is added to an integer, null is converted to 0, so 3 + 0 just results in 3.  
    D. '3null' | When null is concatenated with a string, null becomes a string, which gives us '3null'.  
    E. 4 | true is converted to an integer value of 1 when it is added to an integer.  
    F. 0 | In this operation, both false and null are converted to integers with the value of 0, which leads to 0 + 0.  
    G. '3undefined' | When undefined is concatenated with a string, undefined becomes a string, which gives us '3undefined'.  
    H. NaN | Since we are dealing with subtraction again, the '3' gets converted to an integer with the value of 3, but when we try to convert undefined to an integer, it becomes NaN. So 3 - NaN results in NaN.  
14) A. true | When a comparison is used on values with different types, both values are converted to numbers. So in this case, '2' was converted to 2, which is greater than 1.  
    B. false | When two strings are compared, they are compared character by character. Once a successful comparison is done, the comparison is stopped. When we do '2' < '12', we are actually doing '2' < '1', which results in a successful comparison. So the comparison is stopped and '2' is not less than '1'.  
    C. true | Since the values are different types, they get converted to numbers, so '2' becomes 2. 2 == 2 results in true.  
    D. false | A strict equality operator performs a comparison without doing any type conversions. Since 2 and '2' are different types, they are automatically not equal.  
    E. false | true and 2 are different types, so true gets converted to 1. 1 is not equal to 2 so we get false.
    F. true | We are dealing with a strict equality operator in this comparison but it's ok because both true and Boolean(2) are the same type. Boolean(2) results in true because a single value inside Boolean() becomes true, so true === true results in true.
15) The equality operator (==) will perform a number conversion to both values if they are different types. The strict equality operator (===) won't perform any type conversions if the values are different types. If the two values being compared with an strict equality operator are different types, the comparison automatically results in false.  
16) Check part2-question16.js
17) The result of running this code is the array [2,4,6]. When you first enter the modifyArray function, newArr gets declared as an empty array. Then we enter the for loop which iterates through every value in the array we passed in. For each item in the array we passed in, we call the callback function, which is doSomething, and then we push the result from doSomething into newArr. doSomething just doubles the number that gets passed into it, so since the first item in our array is 1, doSomething returns 2. The next iteration of the loop will result in doSomething returning 4. At the end of the loop, we return newArr which now holds the numbers in from our original array ([1,2,3])but doubled.  
18) Check part2-question18.js
19) This code prints out 1, then 4, then 3, and then it prints out 2 after a small delay. 1 gets printed out first because it's just a regular print statement and it's written above the other lines of code. Line 3 is supposed to print 2, but since there is a delay of 1000 milliseconds, it doesn't print right away. In line 4, we're supposed to print 3 and the delay is 0 milliseconds, but that means that it should be printed in the next event cycle, which means that it isn't printed either. Line 5 prints 4, which means that 4 is the second number printed. After that, we're in the next event cycle so 3 gets printed. And then after the 1000 millisecond delay, 2 gets printed last. 